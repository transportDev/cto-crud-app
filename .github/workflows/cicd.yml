name: CI-CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      deploy:
        description: Deploy after build/test
        required: false
        default: "true"
        type: choice
        options: ["true", "false"]
      image_tag:
        description: Optional image tag to deploy (short SHA) for rollback; defaults to current SHA
        required: false
        type: string
      seed_admin:
        description: Run AdminUserSeeder (first deploy only)
        required: false
        default: "false"
        type: choice
        options: ["true", "false"]

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io

concurrency:
  group: cto-crud-app-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  build_and_test:
    name: Build and Test
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: testing
          MYSQL_USER: testuser
          MYSQL_PASSWORD: testpass
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h 127.0.0.1 -u root -proot"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    defaults:
      run:
        working-directory: ./laravel
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Composer
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache
          key: composer-${{ runner.os }}-${{ hashFiles('laravel/composer.lock') }}
          restore-keys: composer-${{ runner.os }}-

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.2"
          extensions: mbstring, intl, pdo_mysql, zip, bcmath
          coverage: none

      - name: Install Composer deps (with dev)
        run: composer install --prefer-dist --no-ansi --no-interaction --no-progress

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "laravel/package-lock.json"

      - name: Build Frontend
        run: |
          npm ci
          npm run build

      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            if mysqladmin ping -h 127.0.0.1 -u root -proot --silent; then
              echo "MySQL is up"; break
            fi
            echo "Waiting for MySQL..."
            sleep 2
          done

      - name: Run PHPUnit
        env:
          APP_KEY: base64:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
          APP_ENV: testing
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: testing
          DB_USERNAME: testuser
          DB_PASSWORD: testpass
        run: php artisan test --colors=never

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: laravel-build
          path: laravel

  package_push:
    name: Package and Push Images
    needs: build_and_test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: laravel-build
          path: laravel

      - name: Install Composer deps (no dev, optimize)
        run: |
          cd laravel
          composer install --no-dev --prefer-dist --no-ansi --no-interaction --no-progress --optimize-autoloader

      - name: Prepare repo/env names
        id: prep
        run: |
          echo "REPO_LC=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV
          echo "SHA=${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push PHP-FPM image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/prod/php.Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LC }}-php:${{ env.SHA }}
            ghcr.io/${{ env.REPO_LC }}-php:latest
          cache-from: |
            type=gha
            type=registry,ref=ghcr.io/${{ env.REPO_LC }}-php:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=ghcr.io/${{ env.REPO_LC }}-php:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Build and push Nginx image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/prod/nginx.Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LC }}-nginx:${{ env.SHA }}
            ghcr.io/${{ env.REPO_LC }}-nginx:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Production
    needs: [package_push]
    runs-on: [self-hosted, prod, docker]
    environment:
      name: production
    concurrency:
      group: prod-deploy
      cancel-in-progress: false
    if: ${{ (github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && inputs.deploy == 'true') }}
    steps:
      - name: Show deploy URL
        run: echo "Deploying to http://${{ secrets.PRODUCTION_HOST }}"

      - name: Checkout
        uses: actions/checkout@v4

      # 🆕 NEW STEP 1: Initialize First Deployment Infrastructure
      - name: Initialize First Deployment Infrastructure
        shell: bash
        run: |
          set -euo pipefail
          echo "=== FIRST DEPLOYMENT SETUP ==="

          # Create required directories with proper permissions
          sudo mkdir -p /opt/cto-crud/state
          sudo chown -R $USER:$USER /opt/cto-crud

          # Initialize state files for first deployment
          STATE_DIR="/opt/cto-crud/state"
          ACTIVE_FILE="${STATE_DIR}/active_color"

          if [ ! -f "${ACTIVE_FILE}" ]; then
            echo "blue" > "${ACTIVE_FILE}"
            echo "🎯 First deployment detected - initialized with blue environment"
          fi

          # Create backup directory
          mkdir -p /opt/cto-crud/backups

          # Verify Docker daemon is running
          docker info > /dev/null || (echo "❌ Docker daemon not running" && exit 1)

          # Create required networks and volumes
          docker network create cto_net 2>/dev/null || echo "Network cto_net already exists"
          docker volume create cto_db_data 2>/dev/null || echo "Volume cto_db_data already exists"
          docker volume create cto_app_storage 2>/dev/null || echo "Volume cto_app_storage already exists"

          echo "✅ Infrastructure initialization complete"

      - name: Compute image tags and color
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          REPO_LC="${GITHUB_REPOSITORY,,}"
          echo "REPO_LC=${REPO_LC}" >> $GITHUB_ENV
          if [ -n "${{ inputs.image_tag || '' }}" ]; then
            TAG="${{ inputs.image_tag }}"
          else
            TAG="${GITHUB_SHA::7}"
          fi
          echo "TAG=${TAG}" >> $GITHUB_ENV
          STATE_DIR="/opt/cto-crud/state"
          ACTIVE_FILE="${STATE_DIR}/active_color"
          mkdir -p "${STATE_DIR}"
          ACTIVE="blue"
          if [ -f "${ACTIVE_FILE}" ]; then ACTIVE="$(cat "${ACTIVE_FILE}" || echo blue)"; fi
          if [ "${ACTIVE}" = "blue" ]; then NEW="green"; else NEW="blue"; fi
          echo "ACTIVE_COLOR=${ACTIVE}" >> $GITHUB_ENV
          echo "NEW_COLOR=${NEW}" >> $GITHUB_ENV

      - name: Ensure infra (network/volumes) and DB up
        shell: bash
        run: |
          set -euo pipefail
          docker network create cto_net || true
          docker volume create cto_db_data || true
          docker volume create cto_app_storage || true
          mkdir -p env
          cat > env/production.env <<'ENVV'
          APP_NAME=CTO CRUD App
          APP_ENV=production
          APP_DEBUG=false
          APP_URL=http://${{ secrets.PRODUCTION_HOST }}
          APP_KEY=${{ secrets.APP_KEY }}

          LOG_CHANNEL=stack
          LOG_LEVEL=info

          DB_CONNECTION=mysql
          DB_HOST=db
          DB_PORT=3306
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
          DB2_HOST=${{ secrets.DB2_HOST }}
          DB2_PORT=3306 
          DB2_DATABASE=${{ secrets.DB2_DATABASE }}
          DB2_USERNAME=${{ secrets.DB2_USERNAME }}
          DB2_PASSWORD=${{ secrets.DB2_PASSWORD }}

          CACHE_DRIVER=file
          QUEUE_CONNECTION=database
          SESSION_DRIVER=file
          ENVV
          docker compose -p cto_db --env-file env/production.env -f docker-compose.db.yml up -d db
          for i in $(seq 1 60); do
            if docker inspect --format='{{json .State.Health.Status}}' cto_db-db-1 2>/dev/null | grep -q healthy; then
              echo "DB healthy"; break; fi; sleep 2; done

      - name: Preflight up NEW color on localhost staging port
        shell: bash
        env:
          DOCKER_BUILDKIT: "1"
        run: |
          set -euo pipefail
          export IMAGE_PHP="ghcr.io/${REPO_LC}-php:${TAG}"
          export IMAGE_NGINX="ghcr.io/${REPO_LC}-nginx:${TAG}"
          if [ "${NEW_COLOR}" = "blue" ]; then STAGE_PORT=8081; PROJ="cto_blue"; else STAGE_PORT=8082; PROJ="cto_green"; fi
          export WEB_PORT_BIND="127.0.0.1:${STAGE_PORT}"
          echo "Bringing up ${NEW_COLOR} on ${WEB_PORT_BIND}"
          docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml up -d app
          docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml up -d web
          for i in $(seq 1 60); do
            if curl -fsS "http://127.0.0.1:${STAGE_PORT}/healthz" >/dev/null; then
              echo "New stack healthy"; break; fi; sleep 2
            if [ "$i" -eq 60 ]; then echo "Health check failed for new stack" >&2; exit 1; fi
          done

      # 🔄 REPLACED STEP: Enhanced Database Initialization
      - name: Initialize Database and Run Migrations (First Deploy Safe)
        shell: bash
        run: |
          set -euo pipefail

          if [ "${NEW_COLOR}" = "blue" ]; then PROJ="cto_blue"; else PROJ="cto_green"; fi

          echo "=== DATABASE INITIALIZATION ==="

          # Check if this is truly a first deployment
          DB_EXISTS=$(docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
            php artisan tinker --execute="
              try {
                \DB::connection()->getPdo();
                \DB::table(\"migrations\")->count();
                echo \"EXISTS\";
              } catch (\Exception $e) {
                echo \"NEW\";
              }
            "' 2>/dev/null || echo "NEW")

          if [ "$DB_EXISTS" = "NEW" ]; then
            echo "🆕 First deployment detected - initializing fresh database"
            
            # Create database schema and run all migrations
            docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
              php artisan migrate:install --force
              php artisan migrate --force --step
              php artisan db:seed --class=DatabaseSeeder --force
            '
            
            # Always seed admin on first deploy regardless of input
            echo "👤 Creating initial admin user"
            docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
              php artisan db:seed --class=AdminUserSeeder --force || echo "⚠️  Admin seeder not found or failed"
            '
            
          else
            echo "🔄 Existing database detected - running migrations only"
            
            # Create backup before migrations
            BACKUP_FILE="/opt/cto-crud/backups/pre_deploy_$(date +%Y%m%d_%H%M%S).sql"
            docker compose -p cto_db --env-file env/production.env -f docker-compose.db.yml exec -T db sh -c '
              mysqldump -u root -p${MYSQL_ROOT_PASSWORD} ${MYSQL_DATABASE}
            ' > "$BACKUP_FILE"
            echo "💾 Database backup created: $BACKUP_FILE"
            
            # Run migrations
            docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
              php artisan migrate --force
            '
            
            # Optional admin seeding based on input
            if [ "${{ inputs.seed_admin || 'false' }}" = "true" ]; then
              docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
                php artisan db:seed --class=AdminUserSeeder --force || true
              '
            fi
          fi

          # Verify database state
          echo "🔍 Verifying database state..."
          docker compose -p "${PROJ}" --env-file env/production.env -f docker-compose.prod.yml exec -T app sh -lc '
            php artisan migrate:status
            echo "Migration verification complete"
          '

      - name: Switch traffic to NEW color (minimal blip)
        shell: bash
        run: |
          set -euo pipefail

          # Determine project names
          if [ "${ACTIVE_COLOR}" = "blue" ]; then 
            OLD_PROJ="cto_blue"
          else 
            OLD_PROJ="cto_green"
          fi

          if [ "${NEW_COLOR}" = "blue" ]; then 
            NEW_PROJ="cto_blue"
          else 
            NEW_PROJ="cto_green"
          fi

          echo "Switching from ${ACTIVE_COLOR} (${OLD_PROJ}) to ${NEW_COLOR} (${NEW_PROJ})"

          # Set image variables for new deployment
          export IMAGE_PHP="ghcr.io/${REPO_LC}-php:${TAG}"
          export IMAGE_NGINX="ghcr.io/${REPO_LC}-nginx:${TAG}"
          export WEB_PORT_BIND="0.0.0.0:80"

          # 🔧 FIX: Stop old web container FIRST and wait for port to be freed
          if docker ps --format '{{.Names}}' | grep -q "${OLD_PROJ}-web-"; then
            echo "Stopping old web container (${OLD_PROJ})"
            docker compose -p "${OLD_PROJ}" --env-file env/production.env -f docker-compose.prod.yml stop web
            
            # Wait for port 80 to be freed
            for i in $(seq 1 30); do
              if ! netstat -tuln | grep -q ":80 "; then
                echo "Port 80 is now free"
                break
              fi
              echo "Waiting for port 80 to be freed... (${i}/30)"
              sleep 1
            done
          fi

          # Start new web container on port 80
          echo "Starting new web container (${NEW_PROJ}) on port 80"
          docker compose -p "${NEW_PROJ}" --env-file env/production.env -f docker-compose.prod.yml up -d web

          # Start supporting services
          docker compose -p "${NEW_PROJ}" --env-file env/production.env -f docker-compose.prod.yml up -d queue scheduler

          # Clean up old containers if switching colors
          if [ "${ACTIVE_COLOR}" != "${NEW_COLOR}" ]; then
            echo "Cleaning up old environment (${OLD_PROJ})"
            docker compose -p "${OLD_PROJ}" --env-file env/production.env -f docker-compose.prod.yml stop queue scheduler app || true
          fi

          # Update active color state
          echo "${NEW_COLOR}" | sudo tee /opt/cto-crud/state/active_color >/dev/null
          echo "✅ Traffic successfully switched to ${NEW_COLOR} environment"
